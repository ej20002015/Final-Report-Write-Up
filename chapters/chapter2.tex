\chapter{Methods}
\label{chapter2}

This chapter documents the design and implementation of the renderer, as well as outlining the specific physical phenomena that will be used to compare Blinn-Phong shading and PBS.

\section{Design and Implementation}

This section provides a general overview of the design and implementation of the renderer. We begin by discussing the language, technologies and libraries used to develop the program. This is followed by an explanation of the architecture, which has particular focus on how the two different shading models were supported in the same application. Finally, we detail how the development was carried out, providing information on the development tools used and the software engineering methodology adopted.

\subsubsection{Technologies Used}

The renderer is written in C++. This choice was made for a number of reasons. First and foremost, C++ is a language I'm familiar and proficient with, having used it extensively for my own personal projects. Furthermore, real-time rendering is by it's very definition, highly performance orientated, which excludes all but the fastest programming languages. Finally, C++ is the most widely used language in the graphics industry, and as such is widely supported by graphics APIs, and a multitude of useful libraries. The C++17 standard is used as it is modern, supported by many compilers and offers helpful features like the \mintinline{C++}|std::filesystem| library and structured bindings.

Like any renderer, the program utilises a graphics API. OpenGL was chosen for its simplicity, and again, due to my familiarity with it. Although Vulkan and Direct3D boast a much richer and more low-level API, this enhanced control was superfluous to requirements so would have been more of a hindrance than a benefit. Version 4.6 of OpenGL is used.

The renderer is supplemented with several libraries, all of which are listed and described in Appendix \ref{SoftwareLibraries}.

\subsubsection{General Architecture}

The renderer is split into a few main components. The \mintinline{cpp}|Application| class manages the whole program. It is concerned with initialising and shutting down the various subsystems, and also performs the main render loop. The class creates and maintains a \mintinline{cpp}|Window| object, registering callback functions with it to capture pertinent events. The \mintinline{cpp}|Application| class can be regarded as providing the necessary framework for any type of interactive application to be created. The specifics are then left up to the \mintinline{cpp}|Workspace| class. This class acts as a sandbox environment in which resources can be loaded, scenes created and commands given to the renderer. It also holds an instance of the \mintinline{cpp}|Camera| class. This camera is designed to emulate the Unity Engine style of editor camera. The \mintinline{cpp}|Scene| class is a simple way of assembling together models and lights into a 3D scene. Models can be imported using the \mintinline{cpp}|Model| class, or more simplistic meshes, including cubes and spheres, can be created using the \mintinline{cpp}|ModelFactory| class.

The rendering API is exposed by the \mintinline{cpp}|Renderer| class. This includes methods for common utility commands, like setting the clear colour, and drawing commands, such as those for rendering individual models and others for rendering entire scenes. However, the \mintinline{cpp}|Renderer| class doesn't perform any of the actual rendering itself. Instead, depending on the active renderer type, it forwards any rendering calls onto one of the two renderer implementations: either the \mintinline{cpp}|BlinnPhongRendererImplementation| is invoked, or the \mintinline{cpp}|PBRRendererImplementation|. Both feature the same API because both derive from the \mintinline{cpp}|RendererImplementation| pure virtual class, but they behave very differently. As the names would suggest, the \mintinline{cpp}|BlinnPhongRendererImplementation| is a renderer that makes use of the Blinn-Phong shading model, whilst the \mintinline{cpp}|PBRRendererImplementation| is a physically based renderer. The Blinn-Phong renderer is covered in section \ref{BlinnPhongImplementation}, and the details of the physically based renderer, including the specific physically based shading model that is used, is given in section \ref{PBRImplementation}. The whole program is designed so that the renderer implementation being used can be swapped during runtime, making it easy to compare the two approaches.

The two renderer implementations, as well as other parts of the program, make extensive use of the constructs provided by OpenGL. To this end, considerable time was spent abstracting away elements of the OpenGL API behind coherent, clear interfaces. These interfaces include provisions for creating and manipulating vertex buffers, index buffers, framebuffers, textures and shaders. Not only do they serve to create cleaner code, but the interfaces also have the added benefit of hiding the notoriously confusing, state machine nature of OpenGL, behind the more standard OOP paradigm.

\subsubsection{Development Process}

Development was undertaken in an agile manner, being driven by a Kanban board hosted on an Azure DevOps project. A number of days at the start of development were dedicated to assessing the required work, and packaging that into a set of clear, actionable work items. These were arranged hierarchically so that overarching milestones could be identified. Throughout development, new work items were added, old ones were removed when they fell out of scope, and invaluable documentation was accumulated in the items that remained.

Git version control was used and the repo was hosted on the same Azure DevOps project. For each modification I made to the program, I checked out a new branch, and when finished with development, created a pull request. Although I only worked on my own, I found the pull request feature in Azure DevOps to be extremely useful. It allowed me to easily and thoroughly review my changes before I merged them in, which on many occasions meant I identified and solved a bug which otherwise would have made its way into the code base. Had I been simply committing my changes to the main branch, I don't think I would have found it as easy to do that due diligence.

Visual Studio was my IDE of choice. It's an application I have lots of experience with, and one that provides an impressive suite of debugging tools. However, I decided not to directly use the Visual Studio build system, instead opting for Premake. Premake allows for the specification of projects to be done in an intuitive, and build system agnostic way. I found building with Premake to be much easier, and if I choose to migrate the program to other platforms in the future, it should make that process simpler.

Debugging graphics applications is incredibly difficult since most of the important stuff happens on the GPU. Therefore, I also utilised RenderDoc, which is a tool that allows one to inspect an application as it moves through all the stages of the graphics pipeline.

\section{Blinn-Phong Renderer Implementation} \label{BlinnPhongImplementation}

As previously discussed, the Blinn-Phong renderer is responsible for rendering scenes using the Blinn-Phong shading model.

\subsection{Operation of the Renderer}

Upon program initialisation, the renderer creates a few notable items. A framebuffer is created which stores the output fragment colours of the shader program. It is configured to perform \textit{multisampling}, which is a simple anti-aliasing technique~\cite{RealityEngine}. The visual enhancements this yields are judged to be well worth the performance costs it incurs. The key feature that distinguishes this framebuffer from the one used in the physically based renderer, is that it can only store LDR RGB triplets. This is realised in practice by specifying the framebuffer's colour attachment format as \mintinline{cpp}|GL_RGBA8|. Restricting the renderer in this manner is consistent with the description given in section \ref{DynamicRangeAndDisplays}, on how tone mapping is dealt with in non-physically based renderers.

The actual shader program that implements the Blinn-Phong shading model is also created. The program is specified in the OpenGL Shader Language (GLSL), and the source code is read in from external files. This shader program is explored in detail in section \ref{BlinnPhongRendererShaderProgram}.

Following initialisation, the renderer is ready to draw scenes to the screen. When a scene is submitted, several actions take place. First, all the uniforms (modifiable variables within the shader program) that are constant over the whole scene are set. These include details of all the point lights, as well as camera transforms. Secondly, all the models in the scene are iterated through and a draw call submitted for each. During this process, uniforms that specify materials and model transforms will be be constantly changing. Following this, all that is left to do is to output the contents of the framebuffer to the display. This is accomplished by 'blitting' the Blinn-Phong framebuffer to the default framebuffer that is used by the windowing system.

\subsection{Shader Program} \label{BlinnPhongRendererShaderProgram}

The shader program begins by calculating variables that will be used throughout the shading process. Of particular interest is how the surface normal \begin{math}\vect{n}\end{math} is obtained. In both this shader program and that used in the physically based renderer, the normal is either taken from vertex attributes, or, if specified, from a \textit{normal map}. The normal map is a modern method of \textit{bump mapping}, which was first introduced by Blinn in 1978~\cite{BlinnBumpMapping}. The normal map is used to specify \begin{math}\vect{n}\end{math} per pixel, which greatly increases the amount of detail that can be represented on an object's surface.

The Blinn-Phong shading model is then utilised. The ambient lighting component is calculated using equation \ref{eq:BlinnPhongAmbient} with \begin{math}x = 0.2\end{math}. Then for each point light in the scene, the diffuse and specular terms that are set out in equation \ref{eq:BlinnPhong} are evaluated. These values are all summed to give the colour of the fragment. Since the code that implements the Blinn-Phong shading model is so similar to the equations given previously, it is not presented here. However, all the shader code used for both the Blinn-Phong and physically based renderers can be viewed in Appendix \ref{ShaderCode}.

Prior to that colour being outputted to the framebuffer, gamma correction is performed, which was discussed in section \ref{DynamicRangeAndDisplays}. Karis outlines the two common ways in which gamma correction is carried out, and warns against using the approximate approach since it introduces too much error in darker colours~\cite{MovingFrostbitetoPBR}. Heading this advice, both the Blinn-Phong and physically based shader programs perform gamma correction using the exact inverse of the sRGB display transfer function. The code for this is given in Listing \ref{ls:GammaCorrection}.

\begin{listing}[!ht]
\begin{minted}
[
	frame=lines,
	framesep=2mm,
	baselinestretch=1.2,
	fontsize=\footnotesize,
	linenos
]
{glsl}
vec3 gammaCorrectColor(vec3 color)
{
	vec3 SRGBEncodedHigher = (1.055f * pow(color, vec3(1.0f / 2.4f))) - 0.055f;
	vec3 SRGBEncodedLower = 12.92f * color;
	float rSRGBEncoded = (color.r > 0.0031308f) ? SRGBEncodedHigher.r : SRGBEncodedLower.r;
	float gSRGBEncoded = (color.g > 0.0031308f) ? SRGBEncodedHigher.g : SRGBEncodedLower.g;
	float bSRGBEncoded = (color.b > 0.0031308f) ? SRGBEncodedHigher.b : SRGBEncodedLower.b;
	return vec3(rSRGBEncoded, gSRGBEncoded, bSRGBEncoded);
}
\end{minted}
\caption{Shader code for performing gamma correction}
\label{ls:GammaCorrection}
\end{listing}

\subsection{Material Specification} \label{BlinnPhongRendererMaterialSpecification}

As was explained in detail in chapter \ref{chapter1}, the appearance of an object depends heavily on the properties of its surface. These properties are encapsulated within a material. The 3D models that make up a scene are formed from multiple meshes, with each mesh being associated with a material. Materials that are supplied to the Blinn-Phong renderer are of the form given in table \ref{tb:BlinnPhongMaterial}. The texture and vector variants of the same attributes are not intended to be used in conjunction. For example, either a \mintinline{cpp}|diffuseColor| or \mintinline{cpp}|diffuseMap| is specified - not both.

\vspace{20pt}

\begin{table}
\noindent\begin{tabular}{|m{7em}|m{5em}|m{29em}|}
	\hline
	\textbf{Attribute} & \textbf{Data Type} & \textbf{Description} \\
	\hline\hline
	\mintinline{cpp}|diffuseColor| & \mintinline{cpp}|glm::vec4| & Specifies the diffuse colour over the whole mesh. Maps directly to the \begin{math}\vect{c}_{surface_{diff}}\end{math} variable in equation \ref{eq:BlinnPhong}. The fourth component in the vector represents transparency. \\
	\hline
	\mintinline{cpp}|diffuseMap| & \mintinline{cpp}|Texture| & Specifies the diffuse colour per pixel. \\
	\hline
	\mintinline{cpp}|specularColor| & \mintinline{cpp}|glm::vec3| & Specifies the specular colour over the whole mesh. Maps directly to the \begin{math}\vect{c}_{surface_{spec}}\end{math} variable in equation \ref{eq:BlinnPhong}. \\
	\hline
	\mintinline{cpp}|specularMap| & \mintinline{cpp}|Texture| & Specifies the specular colour per pixel. \\
	\hline
	\mintinline{cpp}|shininess| & \mintinline{cpp}|float| & Specifies the shininess of the mesh. Maps directly to the \begin{math}surface_{shininess}\end{math} variable in equation \ref{eq:BlinnPhong}. \\
	\hline
	\mintinline{cpp}|normalMap| & \mintinline{cpp}|Texture| & Optional attribute for specifying surface normals per pixel. \\
	\hline
\end{tabular}
\caption{The specification of a Blinn-Phong material}
\label{tb:BlinnPhongMaterial}
\end{table}

\subsection{Lighting}

Scenes submitted to the Blinn-Phong renderer contain point lights. Each point light is defined by the following attributes: \mintinline{cpp}|worldPosition|, \mintinline{cpp}|diffuseComponent|, and \mintinline{cpp}|lightRadius|. As discussed in section \ref{Illumination}, point lights are a type of punctual light, so have a location, hence \mintinline{cpp}|worldPosition|. The \mintinline{cpp}|diffuseComponent| attribute maps to the \begin{math}\vect{c}_{light_{diff}}\end{math} variable in equation \ref{eq:BlinnPhong}. Then the \begin{math}\vect{c}_{light_{spec}}\end{math} variable in equation \ref{eq:BlinnPhong} is set to a constant white in the shader code. Note that these two RGB triplets are limited to 1 for each channel, unlike the physically-based point lights described in section \ref{Illumination}. Since any outputted colours are stored as LDR values, there is little point in allowing the specification of colours outside this range. Finally there is the \mintinline{cpp}|lightRadius| attribute, which is used when calculating how much a light is attenuated with distance. Both the Blinn-Phong and physically based shader programs use the same attenuation code, and the nature of it is much more physically based than was is typical for use in a non-physically based shader. With this in mind, discussion of how light attenuation is implemented is deferred to section \ref{PBRPointLightModel}.

\section{Physically Based Renderer Implementation} \label{PBRImplementation}

[Intro]

\subsection{Picking the model}

\begin{itemize}
	\item Specular Model
	\begin{itemize}
		\item Which Fresnel term and why
		\item Which NDF and why (show GGX is better)
		\item Which geometry function
		\item Optimisation using Hammon approach
	\end{itemize}
	\item Diffuse Model - justify why I used the lamertian BRDF (reference paper)
	\item framebuffer that does support HDR
\end{itemize}

\subsection{Material Model}

\subsection{Point Light Model} \label{PBRPointLightModel}

\begin{itemize}
	\item Falloff
	\item Adopting the physical approach given by Frostbite
\end{itemize}

\section{Identifying the evaluation scenes}

[Intro]

\subsubsection{Fresnel Effect}

[This is the key point: in the real world the relative proportions of matte and specular appearance change with viewing
angle. - Practitioners guide to reflectance models]

\subsubsection{Long Tailed Specular Highlights}

\subsubsection{HDR? Energy Conservation?}
